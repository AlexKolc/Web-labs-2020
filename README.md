# Веб-программирование 2020 (ИС 4 курс)

## Лабораторная работа 1
<p align="justify">Сверстать сайт с отображением информации о погоде в соответствии с макетами. Отображение сайта должно гибко адаптироваться при изменении ширины – для примера даны макеты для desktop и mobile. Иконки погоды на макетах сделаны заглушками, замените их на свои. Цветовая схема, шрифты могут отличаться от макета, но общая сетка страницы должна быть соблюдена. В верстке должна соблюдаться семантика.</p> 

<p align="justify">Разработка должна вестись итеративно и публиковаться на github. К моменту проверки и сдачи работы репозиторий должен быть публичным. Также должна быть настроена публикация работы на github pages.</p>


### Desktop версия
<p align="center">
  <img src = "https://sun9-49.userapi.com/cnF3w4aYEIdGAzqTr31m1fYzx51mPgZdny2JHg/ekfQQ-jqTn8.jpg">
</p>

### Mobile версия
<p align="center">
  <img src="https://sun9-39.userapi.com/rKyHTD-SUO76IYgnMEErzXmOoSqprIuauGpodA/stXp9OlacdA.jpg">
</p>

## Лабораторная работа 2
<p align="justify">Доработать лабораторную работу 1 для работы с внешним API, позволяющим получить данные о погоде в городе.</p> 

<p align="justify">При первой загрузке страницы происходит запрос пользователя на получение данных о геолокации с использованием HTML5 Geolocation API. Если пользователь соглашается предоставить данные о геолокации – получаем из внешнего API данные о погоде (API можно выбрать самостоятельно). Если нет – запрашиваем информацию для города по умолчанию (город по умолчанию можно выбрать самостоятельно). Эти сведения отображаются в верхней части страницы – "Погода здесь". Иконка погоды должна соответствовать тем данным о погоде, что были получены из API.</p>

<p align="justify">У пользователя есть возможность добавления и удаления городов в избранное. Информация о погоде отображается для всех городов из избранного в соответствии с макетом и реализацией первой лабораторной работы (секция "Избранное"). Список избранных городов сохраняется в LocalStorage. Сами данные о погоде в LocalStorage сохранять не нужно – запрос актуальных сведений происходит при каждой загрузке страницы.</p>

<p align="justify">Пока происходит загрузка данных по конкретному городу/локации – показываем loader и/или сообщение об ожидании загрузки данных. Пример ниже, в вашей реализации может отличаться.</p>

### Пример реализации сообщения о процессе загрузки данных
<p align="center">
  <img src="https://sun9-32.userapi.com/UYaBNwfnayH5FMp7YTcsNJN9klxccPk233twdw/CaU0SM8tlVU.jpg">
</p>

<p align="justify">В случае возникновения ошибки при работе с API пользователь должен получить информацию о возникновении подобной ситуации. Адаптивность страницы должна сохраняться.</p>

<p align="justify">Реализация должна быть на нативном JavaScript, без использования сторонних библиотек.</p>

<p align="justify">Разработка должна вестись итеративно и публиковаться на github. К моменту проверки и сдачи работы репозиторий должен быть публичным. Также должна быть настроена публикация работы на github pages.</p>

## Лабораторная работа 3

<p align="justify">Необходимо доработать лабораторную работу №2, добавив реализацию серверной части приложения. Серверная часть реализуется на NodeJS, допустимо использовать фреймворки вроде Express или Sails.</p>

<p align="justify">Приложение в этой работе становится клиент-серверным, запросы данных о погоде к внешнему API и хранение данных об избранных городах переносятся на сервер. Запросы с клиента отправляются только к самостоятельно реализованной серверной части.</p>

<p align="justify">Для получения данных о погоде из внешнего API по городу используется запрос на GET-endpoint /weather/city (например: /weather/city?q=Moscow), по координатам – /weather/coordinates (например: /weather/coordinates?lat=123&long=456)</p>

<p align="justify">Данные об избранных городах хранятся в базе данных, можно использовать любое SQL/NoSQL решение. Для работы с избранными городами на сервере должен быть реализован endpoint /favourites, обрабатывающий POST-запросы на добавление города и DELETE-запросы на удаление конкретного города из списка. GET-запрос на /favourites возвращает список избранных городов.</p>

<p align="justify">Клиентская логика должна быть адаптирована с учетом этих изменений, включая обработку возможных ошибок.</p>

<p align="justify">Разработка должна вестись итеративно и публиковаться на github. К моменту проверки и сдачи работы репозиторий должен быть публичным.</p>

<p align="justify">Демонстрация работоспособности работы выполняется студентом с помощью демонстрации экрана в zoom. К этому моменту все должно быть подключено и настроено.</p>

## Лабораторная работа 4

<p align="justify">Необходимо доработать лабораторные работы №2 и 3. Полностью покрыть модульными тестами функциональность приложения – как клиентскую, так и серверную часть. Внешние вызовы в тестах должны быть замоканы (mock, подробнее – по ссылке ниже).</p>

<p align="justify">Все функции и endpoint'ы должны быть покрыты тестами. Все развилки бизнес-логики внутри функций должны быть покрыты тест-кейсами. Также не забывайте проверять количество вызовов тех или иных функций. Не забывайте, что некоторые функции и вызовы выполняются асинхронно и необходимо это учитывать при написании тест-кейсов.</p>

<p align="justify">Для выполнения работы вам могут пригодиться такие библиотеки как Mocha (https://mochajs.org), Chai (https://www.chaijs.com) и Sinon (https://sinonjs.org/), можно использовать и другие библиотеки.</p>

<p align="justify">Запуск тестов должен осуществляться с помощью команды npm run test.</p>

<p align="justify">Тесты публикуются в соответствующих репозиториях на Github вместе с приложениями из лабораторных работ №2 и 3.</p>

<p align="justify">На отчете будьте готовы самостоятельно продемонстрировать работу клиентской и серверной частей приложения, а также работу тестов.</p>

<p align="justify">Перед началом отчета нужно будет в чат zoom скинуть список из 4 ссылок с обязательным сохранением следующего порядка:
1. Файл с тест-кейсами для клиентской части приложения.
2. Директория / файл с javascript логикой работы клиентской части приложения.
3. Файл с тест-кейсами для серверной части приложения.
4. Директория / файл с логикой работы серверной части приложения.
</p>
